Maximum flow problems are problems which need to be solved to find the optimal flow possible in a given flow network between two different nodes. Three different algorithms have been implemented to compute the maximum flow in a given network, namely Ford Fulkerson, Scaling Ford Fulkerson and Preflow-Push Algorithm. 

Implemented Depth First Search (DFS) to find the augmenting path in the case of Ford Fulkerson and Scaling Ford Fulkerson algorithms. Both the implementations use a Hashset to keep track of the visited nodes while finding the augmenting path. Once the augmenting path is obtained, it is returned to the calling function as a list of edges in the path. By passing through this list, the bottleneck edge is identified and the flow value is updated. Then, the residual graph is updated according to the new flow values. In addition to this, in Scaling Ford Fulkerson, an additional scaling parameter ‘delta’ is included. The initial delta value is computed and passed to the depth first search function. The DFS considers only the edges that are greater than or equal to delta. When there are no such paths left in the graph, delta value is halved and the DFS function is invoked. This process is repeated until delta is
greater than or equal to 1. 

Preflow-Push algorithm is implemented by maintaining an array list of overflowing nodes. Initially, a saturated Push operation is performed on all the vertices connected to the source. Now the array list contains all these vertices with excess flow, which can be in any order. In each iteration, the nodes with maximum height and excess flow is chosen to perform the Push or Relabel operations as required until the excess flow of the chosen vertex is zero. After each iteration, the node with maximum height is updated to the first
position of the list so that the algorithm always pick the node with the maximum height. The algorithm terminates when it reaches the end of the array list.

Using Hashmap to store vertices as key and values from 0 to n-1 respectively. A separate n*n matrix (where n is the number of vertices) is used to store capacity and flow at each edge. Capacity is maintained for both, the forward edge and the backward edge. Initialize the height of the source to the number of vertices and all others to zero and store it in an array. Another array of size equal to number of vertices is used to maintain the excess flow at each vertex.
